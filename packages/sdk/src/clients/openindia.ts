/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Education API
 * Core API contract for OpenIndia web clients and internal tools
 * OpenAPI spec version: 0.2.0
 */
import { authorizedFetcher } from "../runtime";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

export type GetRiskQueueParams = {
  /**
   * Free-text search (name/email)
   */
  q?: string;
  /**
   * Minimum risk score inclusive
   */
  min?: number;
  /**
   * Maximum risk score inclusive
   */
  max?: number;
};

export type SearchLecturesParams = {
  /**
   * Free text query
   */
  q?: string;
};

export type SearchCoursesParams = {
  /**
   * Free text query
   */
  q?: string;
};

export interface CreatedResource {
  id: string;
}

export interface ScheduleOfficeHourRequest {
  scheduledAt: string;
  with: string;
}

export interface CreateTicketRequest {
  body?: string;
  title: string;
}

export type StudentDetailAllOfTicketsItemStatus =
  (typeof StudentDetailAllOfTicketsItemStatus)[keyof typeof StudentDetailAllOfTicketsItemStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StudentDetailAllOfTicketsItemStatus = {
  open: "open",
  closed: "closed",
} as const;

export type StudentDetailAllOfTicketsItem = {
  createdAt: string;
  id: string;
  status: StudentDetailAllOfTicketsItemStatus;
  title: string;
};

export type StudentDetailAllOfOfficeHoursItemStatus =
  (typeof StudentDetailAllOfOfficeHoursItemStatus)[keyof typeof StudentDetailAllOfOfficeHoursItemStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const StudentDetailAllOfOfficeHoursItemStatus = {
  scheduled: "scheduled",
  completed: "completed",
  canceled: "canceled",
} as const;

export type StudentDetailAllOfOfficeHoursItem = {
  id: string;
  scheduledAt: string;
  status: StudentDetailAllOfOfficeHoursItemStatus;
  with: string;
};

export type StudentDetailAllOfNotesItem = {
  author: string;
  body: string;
  createdAt: string;
  id: string;
};

export type StudentDetailAllOfEnrollmentsItem = {
  course: string;
  courseId: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  progressPct: number;
  startedAt: string;
};

export type StudentDetailAllOf = {
  enrollments: StudentDetailAllOfEnrollmentsItem[];
  notes: StudentDetailAllOfNotesItem[];
  officeHours: StudentDetailAllOfOfficeHoursItem[];
  progressVelocity: number;
  tickets: StudentDetailAllOfTicketsItem[];
};

export interface RiskStudent {
  /** @nullable */
  course?: string | null;
  email: string;
  id: string;
  name: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  riskScore: number;
}

export type StudentDetail = RiskStudent & StudentDetailAllOf;

export type EnqueueJobRequestPayload = { [key: string]: unknown };

export interface EnqueueJobRequest {
  payload: EnqueueJobRequestPayload;
  /** @maxLength 128 */
  type: string;
}

export type OutboxJobPayload = { [key: string]: unknown };

export interface OutboxJob {
  createdAt: string;
  id: string;
  payload: OutboxJobPayload;
  /** @nullable */
  processedAt?: string | null;
  /** @maxLength 128 */
  type: string;
}

export interface ReindexResponse {
  /** @minimum 0 */
  enqueued: number;
  ok: boolean;
}

export interface LectureSearchHit {
  id: string;
  moduleId?: string;
  /** @nullable */
  summary?: string | null;
  title: string;
}

export type CourseSearchHitVisibility =
  (typeof CourseSearchHitVisibility)[keyof typeof CourseSearchHitVisibility];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CourseSearchHitVisibility = {
  public: "public",
  private: "private",
  unlisted: "unlisted",
} as const;

export interface CourseSearchHit {
  /** @nullable */
  description?: string | null;
  id: string;
  slug?: string;
  tags?: string[];
  title: string;
  visibility?: CourseSearchHitVisibility;
}

export interface CreateLectureRequest {
  /** @nullable */
  contentMd?: string | null;
  moduleId: string;
  /** @minimum 0 */
  position: number;
  /** @nullable */
  summary?: string | null;
  title: string;
}

export interface Lecture {
  /** @nullable */
  contentMd?: string | null;
  createdAt?: string;
  /**
   * @minimum 1
   * @maximum 14400
   */
  durationSeconds?: number;
  id?: string;
  isPublished?: boolean;
  moduleId: string;
  /** @minimum 0 */
  position: number;
  /**
   * @maxLength 2000
   * @nullable
   */
  summary?: string | null;
  /**
   * @minLength 2
   * @maxLength 160
   */
  title: string;
  updatedAt?: string;
}

export interface EnrollmentResponse {
  enrollmentId: string;
  success: boolean;
}

export type UpdateCourseRequestVisibility =
  (typeof UpdateCourseRequestVisibility)[keyof typeof UpdateCourseRequestVisibility];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UpdateCourseRequestVisibility = {
  public: "public",
  private: "private",
  unlisted: "unlisted",
} as const;

export interface UpdateCourseRequest {
  /** @nullable */
  description?: string | null;
  estimatedMinutes?: number;
  orgId?: string;
  slug?: string;
  tags?: string[];
  title?: string;
  visibility?: UpdateCourseRequestVisibility;
}

export type CreateCourseRequestAllOf = {
  readonly createdAt?: unknown;
  readonly id?: unknown;
  readonly updatedAt?: unknown;
};

export type CourseVisibility =
  (typeof CourseVisibility)[keyof typeof CourseVisibility];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CourseVisibility = {
  public: "public",
  private: "private",
  unlisted: "unlisted",
} as const;

export interface Course {
  createdAt?: string;
  /**
   * @maxLength 4000
   * @nullable
   */
  description?: string | null;
  /**
   * @minimum 1
   * @maximum 100000
   */
  estimatedMinutes?: number;
  id?: string;
  orgId: string;
  /**
   * @minLength 3
   * @maxLength 120
   * @pattern ^[a-z0-9-]+$
   */
  slug: string;
  /** @maxItems 20 */
  tags?: string[];
  /**
   * @minLength 3
   * @maxLength 160
   */
  title: string;
  updatedAt?: string;
  visibility?: CourseVisibility;
}

export type CreateCourseRequest = Course & CreateCourseRequestAllOf;

export interface AuthTokenResponse {
  /** JWT bearer token */
  access_token: string;
}

export interface AuthLoginRequest {
  email: string;
  /** @minLength 6 */
  password: string;
}

/**
 * @summary Authenticate a user by email and password
 */
export type loginResponse = {
  data: AuthTokenResponse;
  status: number;
};

export const getLoginUrl = () => {
  return `/api/auth/login`;
};

export const login = async (
  authLoginRequest: AuthLoginRequest,
  options?: RequestInit,
): Promise<loginResponse> => {
  return authorizedFetcher<Promise<loginResponse>>(getLoginUrl(), {
    ...options,
    method: "POST",
    body: JSON.stringify(authLoginRequest),
  });
};

/**
 * @summary List all courses for the current tenant
 */
export type listCoursesResponse = {
  data: Course[];
  status: number;
};

export const getListCoursesUrl = () => {
  return `/api/courses`;
};

export const listCourses = async (
  options?: RequestInit,
): Promise<listCoursesResponse> => {
  return authorizedFetcher<Promise<listCoursesResponse>>(getListCoursesUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * @summary Create a new course
 */
export type createCourseResponse = {
  data: Course;
  status: number;
};

export const getCreateCourseUrl = () => {
  return `/api/courses`;
};

export const createCourse = async (
  createCourseRequest: NonReadonly<CreateCourseRequest>,
  options?: RequestInit,
): Promise<createCourseResponse> => {
  return authorizedFetcher<Promise<createCourseResponse>>(
    getCreateCourseUrl(),
    {
      ...options,
      method: "POST",
      body: JSON.stringify(createCourseRequest),
    },
  );
};

/**
 * @summary Update a course
 */
export type updateCourseResponse = {
  data: Course;
  status: number;
};

export const getUpdateCourseUrl = (id: string) => {
  return `/api/courses/${id}`;
};

export const updateCourse = async (
  id: string,
  updateCourseRequest: UpdateCourseRequest,
  options?: RequestInit,
): Promise<updateCourseResponse> => {
  return authorizedFetcher<Promise<updateCourseResponse>>(
    getUpdateCourseUrl(id),
    {
      ...options,
      method: "PATCH",
      body: JSON.stringify(updateCourseRequest),
    },
  );
};

/**
 * @summary Enroll the active user in a course
 */
export type enrollInCourseResponse = {
  data: EnrollmentResponse;
  status: number;
};

export const getEnrollInCourseUrl = (id: string) => {
  return `/api/courses/${id}/enroll`;
};

export const enrollInCourse = async (
  id: string,
  options?: RequestInit,
): Promise<enrollInCourseResponse> => {
  return authorizedFetcher<Promise<enrollInCourseResponse>>(
    getEnrollInCourseUrl(id),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * @summary Search published courses
 */
export type searchCoursesResponse = {
  data: CourseSearchHit[];
  status: number;
};

export const getSearchCoursesUrl = (params?: SearchCoursesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/api/courses/search?${normalizedParams.toString()}`;
};

export const searchCourses = async (
  params?: SearchCoursesParams,
  options?: RequestInit,
): Promise<searchCoursesResponse> => {
  return authorizedFetcher<Promise<searchCoursesResponse>>(
    getSearchCoursesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * @summary List lessons for all courses
 */
export type listLecturesResponse = {
  data: Lecture[];
  status: number;
};

export const getListLecturesUrl = () => {
  return `/api/lessons`;
};

export const listLectures = async (
  options?: RequestInit,
): Promise<listLecturesResponse> => {
  return authorizedFetcher<Promise<listLecturesResponse>>(
    getListLecturesUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * @summary Create a lesson under a module
 */
export type createLectureResponse = {
  data: Lecture;
  status: number;
};

export const getCreateLectureUrl = () => {
  return `/api/lessons`;
};

export const createLecture = async (
  createLectureRequest: CreateLectureRequest,
  options?: RequestInit,
): Promise<createLectureResponse> => {
  return authorizedFetcher<Promise<createLectureResponse>>(
    getCreateLectureUrl(),
    {
      ...options,
      method: "POST",
      body: JSON.stringify(createLectureRequest),
    },
  );
};

/**
 * @summary Search lessons by title or content
 */
export type searchLecturesResponse = {
  data: LectureSearchHit[];
  status: number;
};

export const getSearchLecturesUrl = (params?: SearchLecturesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/api/lessons/search?${normalizedParams.toString()}`;
};

export const searchLectures = async (
  params?: SearchLecturesParams,
  options?: RequestInit,
): Promise<searchLecturesResponse> => {
  return authorizedFetcher<Promise<searchLecturesResponse>>(
    getSearchLecturesUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * @summary Trigger re-index background job
 */
export type reindexSearchResponse = {
  data: ReindexResponse;
  status: number;
};

export const getReindexSearchUrl = () => {
  return `/api/v1/search/reindex`;
};

export const reindexSearch = async (
  options?: RequestInit,
): Promise<reindexSearchResponse> => {
  return authorizedFetcher<Promise<reindexSearchResponse>>(
    getReindexSearchUrl(),
    {
      ...options,
      method: "POST",
    },
  );
};

/**
 * @summary List queued outbox jobs
 */
export type listJobsResponse = {
  data: OutboxJob[];
  status: number;
};

export const getListJobsUrl = () => {
  return `/api/jobs/outbox`;
};

export const listJobs = async (
  options?: RequestInit,
): Promise<listJobsResponse> => {
  return authorizedFetcher<Promise<listJobsResponse>>(getListJobsUrl(), {
    ...options,
    method: "GET",
  });
};

/**
 * @summary Enqueue a job into the outbox
 */
export type enqueueJobResponse = {
  data: OutboxJob;
  status: number;
};

export const getEnqueueJobUrl = () => {
  return `/api/jobs/outbox`;
};

export const enqueueJob = async (
  enqueueJobRequest: EnqueueJobRequest,
  options?: RequestInit,
): Promise<enqueueJobResponse> => {
  return authorizedFetcher<Promise<enqueueJobResponse>>(getEnqueueJobUrl(), {
    ...options,
    method: "POST",
    body: JSON.stringify(enqueueJobRequest),
  });
};

/**
 * @summary List at-risk students (risk triage queue)
 */
export type getRiskQueueResponse = {
  data: RiskStudent[];
  status: number;
};

export const getGetRiskQueueUrl = (params?: GetRiskQueueParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value === null) {
      normalizedParams.append(key, "null");
    } else if (value !== undefined) {
      normalizedParams.append(key, value.toString());
    }
  });

  return `/api/v1/ssu/risk?${normalizedParams.toString()}`;
};

export const getRiskQueue = async (
  params?: GetRiskQueueParams,
  options?: RequestInit,
): Promise<getRiskQueueResponse> => {
  return authorizedFetcher<Promise<getRiskQueueResponse>>(
    getGetRiskQueueUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * @summary Get student detail profile
 */
export type getStudentResponse = {
  data: StudentDetail;
  status: number;
};

export const getGetStudentUrl = (id: string) => {
  return `/api/v1/ssu/students/${id}`;
};

export const getStudent = async (
  id: string,
  options?: RequestInit,
): Promise<getStudentResponse> => {
  return authorizedFetcher<Promise<getStudentResponse>>(getGetStudentUrl(id), {
    ...options,
    method: "GET",
  });
};

/**
 * @summary Create a support ticket for a student
 */
export type createTicketResponse = {
  data: CreatedResource;
  status: number;
};

export const getCreateTicketUrl = (id: string) => {
  return `/api/v1/ssu/students/${id}/tickets`;
};

export const createTicket = async (
  id: string,
  createTicketRequest: CreateTicketRequest,
  options?: RequestInit,
): Promise<createTicketResponse> => {
  return authorizedFetcher<Promise<createTicketResponse>>(
    getCreateTicketUrl(id),
    {
      ...options,
      method: "POST",
      body: JSON.stringify(createTicketRequest),
    },
  );
};

/**
 * @summary Schedule an office hour session for a student
 */
export type scheduleOfficeHourResponse = {
  data: CreatedResource;
  status: number;
};

export const getScheduleOfficeHourUrl = (id: string) => {
  return `/api/v1/ssu/students/${id}/office-hours`;
};

export const scheduleOfficeHour = async (
  id: string,
  scheduleOfficeHourRequest: ScheduleOfficeHourRequest,
  options?: RequestInit,
): Promise<scheduleOfficeHourResponse> => {
  return authorizedFetcher<Promise<scheduleOfficeHourResponse>>(
    getScheduleOfficeHourUrl(id),
    {
      ...options,
      method: "POST",
      body: JSON.stringify(scheduleOfficeHourRequest),
    },
  );
};
